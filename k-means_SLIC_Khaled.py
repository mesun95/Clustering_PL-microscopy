{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "308b3e54-4b49-4ba9-b521-b796a2f57d35",
   "metadata": {},
   "outputs": [],
   "source": [
    "## created on 19.01.2026 for the ML course project\n",
    "## Part (1/4) is for ROI selection for PL and Reflection TIFF images\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.patches import Rectangle\n",
    "from tifffile import imread, imwrite\n",
    "import os\n",
    "\n",
    "# ===============================\n",
    "# 1Ô∏è‚É£ Load TIFFs\n",
    "# ===============================\n",
    "pl = imread(r\"xx.tif\")   #add tif PL image location\n",
    "refl = imread(r\"xx.tif\")    #add tif reflection image location\n",
    "\n",
    "# ===============================\n",
    "# 2Ô∏è‚É£ Convert to grayscale\n",
    "# ===============================\n",
    "def to_gray(img):\n",
    "    if img.ndim == 3:\n",
    "        img = img[..., :3].mean(axis=2)\n",
    "    return img.astype(np.float32)\n",
    "\n",
    "pl = to_gray(pl)\n",
    "refl = to_gray(refl)\n",
    "\n",
    "# ===============================\n",
    "# 3Ô∏è‚É£ Crop to common size\n",
    "# ===============================\n",
    "H = min(pl.shape[0], refl.shape[0])\n",
    "W = min(pl.shape[1], refl.shape[1])\n",
    "\n",
    "pl = pl[:H, :W]\n",
    "refl = refl[:H, :W]\n",
    "\n",
    "# Image center\n",
    "cx = W // 2\n",
    "cy = H // 2\n",
    "\n",
    "# ===============================\n",
    "# 4Ô∏è‚É£ Define ROIs (independent)\n",
    "# ===============================\n",
    "# ---- PL ROI ----\n",
    "half_size_pl = 300\n",
    "dx_pl = 0\n",
    "dy_pl = 0\n",
    "\n",
    "roi_pl_xmin = cx - half_size_pl + dx_pl\n",
    "roi_pl_xmax = cx + half_size_pl + dx_pl\n",
    "roi_pl_ymin = cy - half_size_pl + dy_pl\n",
    "roi_pl_ymax = cy + half_size_pl + dy_pl\n",
    "\n",
    "print(\"roi_pl_xmin = \", roi_pl_xmin, \"roi_pl_xmax = \", roi_pl_xmax, \"roi_pl_ymin = \", roi_pl_ymin, \"roi_pl_ymax  = \", roi_pl_ymax)\n",
    "\n",
    "# ---- Reflection ROI ----\n",
    "half_size_refl = 300\n",
    "dx_refl = 0\n",
    "dy_refl = 0\n",
    "roi_refl_xmin = cx - half_size_refl + dx_refl\n",
    "roi_refl_xmax = cx + half_size_refl + dx_refl\n",
    "roi_refl_ymin = cy - half_size_refl + dy_refl\n",
    "roi_refl_ymax = cy + half_size_refl + dy_refl\n",
    "\n",
    "print(\"roi_refl_xmin = \", roi_refl_xmin, \"roi_refl_xmax = \", roi_refl_xmax, \"roi_refl_ymin = \", roi_refl_ymin, \"roi_refl_ymax  = \", roi_refl_ymax)\n",
    "\n",
    "# ===============================\n",
    "# 5Ô∏è‚É£ Show ROIs as rectangles\n",
    "# ===============================\n",
    "def show_roi(img, xmin, xmax, ymin, ymax, title, cmap):\n",
    "    fig, ax = plt.subplots(figsize=(6,6))\n",
    "    ax.imshow(img, cmap=cmap)\n",
    "    rect = Rectangle(\n",
    "        (xmin, ymin),\n",
    "        xmax - xmin,\n",
    "        ymax - ymin,\n",
    "        edgecolor='cyan',\n",
    "        facecolor='none',\n",
    "        linewidth=2\n",
    "    )\n",
    "    ax.add_patch(rect)\n",
    "    ax.set_title(title)\n",
    "    ax.axis(\"off\")\n",
    "    plt.show()\n",
    "\n",
    "show_roi(pl, roi_pl_xmin, roi_pl_xmax, roi_pl_ymin, roi_pl_ymax,\n",
    "         \"PL with ROI\", \"inferno\")\n",
    "\n",
    "show_roi(refl, roi_refl_xmin, roi_refl_xmax, roi_refl_ymin, roi_refl_ymax,\n",
    "         \"Reflection with ROI\", \"gray\")\n",
    "\n",
    "# ===============================\n",
    "# 6Ô∏è‚É£ Crop ROIs\n",
    "# ===============================\n",
    "pl_roi = pl[roi_pl_ymin:roi_pl_ymax, roi_pl_xmin:roi_pl_xmax]\n",
    "refl_roi = refl[roi_refl_ymin:roi_refl_ymax, roi_refl_xmin:roi_refl_xmax]\n",
    "\n",
    "# ===============================\n",
    "# 7Ô∏è‚É£ Visual sanity check\n",
    "# ===============================\n",
    "plt.figure(figsize=(8,4))\n",
    "\n",
    "#plt.subplot(1,2,1)\n",
    "plt.imshow(pl_roi, cmap=\"inferno\")\n",
    "plt.title(\"PL ROI\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.subplot(1,2,2)\n",
    "plt.imshow(refl_roi, cmap=\"gray\")\n",
    "plt.title(\"Reflection ROI\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.show()\n",
    "\n",
    "# ===============================\n",
    "# 8Ô∏è‚É£ Save ROIs properly\n",
    "# ===============================\n",
    "output_dir = r\"xx\"   #add output folder location\n",
    "os.makedirs(output_dir, exist_ok=True)\n",
    "\n",
    "# Normalize before saving (VERY IMPORTANT)\n",
    "def normalize_uint16(img):\n",
    "    img = img - img.min()\n",
    "    img = img / img.max()\n",
    "    return (img * 65535).astype(np.uint16)\n",
    "\n",
    "imwrite(os.path.join(output_dir, \"PL.tif\"),\n",
    "        normalize_uint16(pl_roi))\n",
    "\n",
    "imwrite(os.path.join(output_dir, \"refl.tif\"),\n",
    "        normalize_uint16(refl_roi))\n",
    "\n",
    "print(\"‚úÖ ROI TIFFs saved correctly.\")\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "754b96f6-e289-4807-902b-b35a0bfea0a5",
   "metadata": {},
   "outputs": [],
   "source": [
    "## created on 19.01.2026 for the ML course project\n",
    "## Part (2/4) is for Basic K-Means Clustering for PL and Reflection TIFF images\n",
    "\n",
    "import numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib.colors import ListedColormap\n",
    "from matplotlib.widgets import RectangleSelector\n",
    "\n",
    "from tifffile import imread\n",
    "from sklearn.cluster import KMeans\n",
    "from sklearn.preprocessing import StandardScaler\n",
    "#from sklearn.metrics import silhouette_score\n",
    "\n",
    "pl_raw = imread(r\"pl_xx.tiff\").astype(float)   #add tif PL image location\n",
    "refl_raw = imread(r\"refl_xx.tiff\").astype(float)   #add tif refl image location\n",
    "\n",
    "#check data shape\n",
    "#print(\"PL shape:\", pl.shape)\n",
    "#print(\"Reflection shape:\", refl.shape)\n",
    "\n",
    "# Convert RGBA ‚Üí grayscale\n",
    "def to_gray(img):\n",
    "    if img.ndim == 3:\n",
    "        img = img[..., :3]   # drop alpha if present\n",
    "        return img.mean(axis=2)  # RGB ‚Üí gray\n",
    "    return img.astype(float)\n",
    "\n",
    "pl = to_gray(pl_raw)\n",
    "refl = to_gray(refl_raw)\n",
    "\n",
    "# Crop to common size\n",
    "h = min(pl.shape[0], refl.shape[0])\n",
    "w = min(pl.shape[1], refl.shape[1])\n",
    "\n",
    "pl = pl[:h, :w]\n",
    "refl = refl[:h, :w]\n",
    "\n",
    "print(\"Cropped shape:\", pl.shape)\n",
    "\n",
    "\n",
    "\n",
    "##Quick visual check \n",
    "plt.figure(figsize=(10,4))\n",
    "\n",
    "plt.subplot(1,2,1)\n",
    "plt.imshow(pl, cmap=\"inferno\")\n",
    "plt.title(\"PL (grayscale)\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.subplot(1,2,2)\n",
    "plt.imshow(refl, cmap=\"gray\")\n",
    "plt.title(\"Reflection (grayscale)\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.show()\n",
    "\n",
    "\n",
    "## Normalise images for display\n",
    "pl_disp = (pl - pl.min()) / (pl.max() - pl.min())\n",
    "refl_disp = (refl - refl.min()) / (refl.max() - refl.min())\n",
    "\n",
    "# Create active area mask from reflection\n",
    "# Reflection is usually brighter on the substrate\n",
    "threshold = np.percentile(refl_disp, 40)\n",
    "\n",
    "active_mask = refl_disp < threshold\n",
    "\n",
    "# Visualise mask\n",
    "# üëâ You should now clearly see film vs background.\n",
    "plt.figure(figsize=(12,4))\n",
    "\n",
    "plt.subplot(1,3,1)\n",
    "plt.imshow(pl_disp, cmap=\"inferno\")\n",
    "plt.title(\"PL\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.subplot(1,3,2)\n",
    "plt.imshow(refl_disp, cmap=\"gray\")\n",
    "plt.title(\"Reflection\")\n",
    "plt.axis(\"off\")\n",
    "\n",
    "plt.subplot(1,3,3)\n",
    "plt.imshow(active_mask, cmap=\"gray\")\n",
    "plt.title(\"Active area mask\")\n",
    "plt.axis(\"off\")\n",
    "plt.savefig(r\"xx.png\", dpi=300, bbox_inches='tight')  # Saves to current folder\n",
    "plt.show()\n",
    "\n",
    "## K-means clustering (film only) #####\n",
    "\n",
    "## Build feature matrix\n",
    "pl_norm = (pl - np.mean(pl)) / np.std(pl)\n",
    "refl_norm = (refl - np.mean(refl)) / np.std(refl)\n",
    "\n",
    "yy, xx = np.indices(pl.shape)\n",
    "\n",
    "X = np.column_stack([\n",
    "    pl_norm[active_mask],\n",
    "    refl_norm[active_mask],\n",
    "    xx[active_mask] / xx.max(),\n",
    "    yy[active_mask] / yy.max()\n",
    "])\n",
    "\n",
    "X = StandardScaler().fit_transform(X)\n",
    "\n",
    "\n",
    "\n",
    "## Choose number of clusters k (silhouette)\n",
    "#sil_scores = {}\n",
    "\n",
    "#for k in range(2, 6):\n",
    "#    labels = KMeans(n_clusters=k, random_state=0).fit_predict(X)\n",
    "#    score = silhouette_score(X, labels)\n",
    "#    print(f\"k={k}, silhouette={score:.3f}\")\n",
    "\n",
    "# Final clustering - Run K-means\n",
    "\n",
    "# Run K-means\n",
    "k = 3  # Pick a reasonable k (usually 2‚Äì4), start simple\n",
    "labels = KMeans(n_clusters=k, random_state=0).fit_predict(X)\n",
    "\n",
    "# Put clusters back into image\n",
    "\n",
    "cluster_map = np.full(pl.shape, -1)\n",
    "cluster_map[active_mask] = labels\n",
    "\n",
    "\n",
    "#best_k = max(sil_scores, key=sil_scores.get)\n",
    "#print(\"Best k:\", best_k)\n",
    "\n",
    "## Run final K-means\n",
    "#kmeans = KMeans(n_clusters=best_k, random_state=0)\n",
    "#labels = kmeans.fit_predict(X)\n",
    "\n",
    "## Reshape labels to image\n",
    "#cluster_map = labels.reshape(pl.shape)\n",
    "\n",
    "## Visualise results \n",
    "cmap = ListedColormap(plt.cm.tab10.colors[:k])\n",
    "\n",
    "plt.figure(figsize=(6,6))\n",
    "plt.imshow(cluster_map, cmap=cmap, vmin=0, vmax=k-1)\n",
    "plt.title(\"K-means clusters\")\n",
    "plt.axis(\"off\")\n",
    "cbar = plt.colorbar(ticks=range(k))\n",
    "cbar.set_label(\"Cluster ID\")\n",
    "\n",
    "plt.savefig(r\"xx.png\", dpi=300, bbox_inches='tight')  # Saves to current folder\n",
    "plt.show()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "27c00c6f-674a-4f32-bc35-3207632322fa",
   "metadata": {},
   "outputs": [],
   "source": [
    "## created on 20.01.2026 for the ML course project\n",
    "## Part (3/4) is for definition of superpixels for SLIC for PL and Reflection TIFF images\n",
    "\n",
    "from skimage.segmentation import slic\n",
    "from skimage.color import label2rgb\n",
    "\n",
    "#Build 2-channel image\n",
    "img = np.stack([pl_disp, refl_disp], axis=2)\n",
    "\n",
    "#Run SLIC (active area only)\n",
    "segments = slic(\n",
    "    img,\n",
    "    n_segments=300,        # controls region size\n",
    "    compactness=10,        # higher = more spatial\n",
    "    mask=active_mask,\n",
    "    start_label=0\n",
    ")\n",
    "\n",
    "#Visualise superpixels\n",
    "#plt.figure(figsize=(6,6))\n",
    "#plt.imshow(label2rgb(segments, img, kind='avg'))\n",
    "#plt.title(\"SLIC superpixels\")\n",
    "#plt.axis(\"off\")\n",
    "#plt.show()\n",
    "\n",
    "#Sanity check (important)\n",
    "print(\"Segments:\", segments.min(), segments.max())\n",
    "print(\"Unique segments:\", len(np.unique(segments)))\n",
    "\n",
    "\n",
    "# OPTIONAL: Cluster the superpixels (best practice)\n",
    "#Extract superpixel features\n",
    "labels = np.unique(segments[segments >= 0])\n",
    "\n",
    "features = []\n",
    "for lab in labels:\n",
    "    mask = segments == lab\n",
    "    features.append([\n",
    "        pl_norm[mask].mean(),\n",
    "        refl_norm[mask].mean()\n",
    "    ])\n",
    "\n",
    "features = np.array(features)\n",
    "\n",
    "#K-means on superpixels\n",
    "k = 3\n",
    "sp_labels = KMeans(n_clusters=k, random_state=0).fit_predict(features)\n",
    "#Map back to image\n",
    "cluster_map = np.full(pl.shape, -1)\n",
    "for lab, cl in zip(labels, sp_labels):\n",
    "    cluster_map[segments == lab] = cl\n",
    "\n",
    "#Plot final result\n",
    "plt.figure(figsize=(6,6))\n",
    "plt.imshow(label2rgb(segments, pl_disp, kind='overlay', alpha=0.4))\n",
    "plt.title(\"SLIC superpixels over PL\")\n",
    "plt.axis(\"off\")\n",
    "plt.savefig(r\"Superpixels.png\", dpi=300, bbox_inches='tight')  # Saves to output folder\n",
    "plt.show()\n",
    "\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7beaa016-6af8-4090-8f76-1f72db2cef4e",
   "metadata": {},
   "outputs": [],
   "source": [
    "## created on 20.01.2026 for the ML course project\n",
    "## Part (4/4) is for showing clustering with Hybrid K-Means & SLIC for PL and Reflection TIFF images\n",
    "\n",
    "from matplotlib.colors import ListedColormap\n",
    "#üîπ Step 1 ‚Äî Extract superpixel features (mean PL, mean reflection)\n",
    "labels = np.unique(segments)\n",
    "\n",
    "features = []\n",
    "for lab in labels:\n",
    "    mask = segments == lab\n",
    "    features.append([\n",
    "        pl_norm[mask].mean(),\n",
    "        refl_norm[mask].mean()\n",
    "    ])\n",
    "\n",
    "features = np.array(features)\n",
    "\n",
    "#üîπ Step 2 ‚Äî Cluster superpixels\n",
    "from sklearn.cluster import KMeans\n",
    "\n",
    "k = 2\n",
    "sp_clusters = KMeans(n_clusters=k, random_state=0).fit_predict(features)\n",
    "\n",
    "#üîπ Step 3 ‚Äî Map clusters back to image\n",
    "cluster_map = np.zeros_like(segments)\n",
    "for lab, cl in zip(labels, sp_clusters):\n",
    "    cluster_map[segments == lab] = cl\n",
    "\n",
    "#üîπ Step 4 ‚Äî Visualise clean clusters\n",
    "cmap = ListedColormap(plt.cm.tab10.colors[:k])\n",
    "\n",
    "plt.figure(figsize=(6,6))\n",
    "plt.imshow(cluster_map, cmap=cmap, vmin=0, vmax=k-1)\n",
    "plt.title(\"SLIC + K-means clusters\")\n",
    "plt.axis(\"off\")\n",
    "cbar = plt.colorbar(ticks=range(k))\n",
    "cbar.set_label(\"Cluster ID\")\n",
    "#cbar.set_ticks([])  # Remove default ticks\n",
    "plt.savefig(r\"SLICandK.png\", dpi=300, bbox_inches='tight')  # Saves to output folder\n",
    "plt.show()\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.11"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
